# O'kanban - SPA E02 - Fetch et templates

[Rappel : lien pour cr√©er des issues](https://github.com/O-clock-Sigurd/Soutien-ateliers/issues)

‚ö†Ô∏è **Le retour du front !** Pensez √† `console.log` apr√®s chaque ligne pour tester r√©guli√®rement ‚ö†Ô∏è

‚ö†Ô∏è `Commit` entre chaque √©tape ! On ne le dira jamais assez ü§™

## √âtape 1 - Mise en place

### 1.1. Lancer le back ü¶ø

R√©-ouvrir le projet O'kanban API (backend) et d√©marrer l'API sur le port de votre choix.

V√©rifier que l'API r√©pond correctement (avec Insomnia par exemple), et que votre code est √† jour par rapport √† la correction.

### 1.2. Lancer le front ü¶æ

Pour ce projet, le frontend est ind√©pendant du backend, et on communiquera avec lui via son API.

C√¥t√© frontend, tout va se passer dans le navigateur. On va donc coder directement des fichiers statiques (`HTML`, `CSS`, `JS`). Retour au d√©but de la formation, en quelque sorte !

L'option la plus simple pour **lancer un serveur front** est d'utiliser l'extension VSCode `Live Server` en cliquant droit sur le fichier `html` √† ouvrir,
et choisir `Open with Live Server`. On profite ainsi du _hot reload_ (rechargement automatique de la page en cas de modification du code c√¥t√© front).

### 1.3. Prise en main du code üëÄ

Commencer par **lire les fichiers d'int√©gration fournis** et rep√©rer les √©l√©ments sur la page.
L'int√©gration propos√©e utilise le framework [CSS Bulma](https://bulma.io/). Un petit tour sur la documentation ne fait pas de mal.

Tu vas rencontrer de nombreux templates.
Un template, en html, est une sorte de composant qui n'est pas visible dans le DOM, mais qui contient du code HTML.
Celui-ci est clonable afin de l'injecter, et de potentiellement le personnaliser, afin de l'incorporer dans un autre √©l√©ment du DOM.

## √âtape 2 - La fen√™tre de dialogue

> Une fen√™tre de dialogue est une fen√™tre r√©duite qui s'ouvre dans le navigateur par dessus le contenu courant, un peu comme une `alert()` ou un `prompt()`, mais en moins moche et surtout personnalisable et stylisable en CSS.

### 2.1. Ouvrir la fen√™tre de dialogue

Tu as d√ª remarquer le bouton `Ajouter une liste`. Mais ce bouton‚Ä¶ ne fait rien !

**Objectif** : lorsque le l'utilisateur clique sur le bouton, la fen√™tre de dialogue (`<dialog>`) comportant le formulaire d'ajout de liste s'ouvre. √Ä toi de jouer !

<details><summary>De l'aide ?</summary>

[documentation `dialog`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog)

<details><summary>Pseudo code</summary>

```js

// - on selectionne le bouton d'ajout de liste
// - on √©coute le clic sur ce bouton, et en cas de clic on d√©clenche les instructions suivantes :
//   - on selectionne la fenetre de dialogue par son id
//   - on l'ouvre via la m√©thode `.showModal()`
```

</details>

</details>

### 2.2. Fermer la fen√™tre de dialogue

On souhaite pouvoir fermer la fen√™tre de dialogue de 3 fa√ßons diff√©rentes :

- un clic sur la croix `x` en haut √† droite de celle-ci ;
- un clic sur le bouton `Annuler` en bas ;
- un clic sur le fond gris√© derri√®re la fen√™tre de dialogue.

L'objectif de cette √©tape est de faire fonctionner ces boutons.

<details><summary>De l'aide ?</summary>

L'id√©e est d'utiliser la m√©thode `.close()` de la fen√™tre de dialogue lors d'un clic sur l'un des deux boutons. Comme d'habitude :

- s√©lectionner tous les boutons, et pour chaque bouton
  - poser un √©couteur d'√©v√®nement sur le bouton;
  - s√©lectionner la modale ouverte ;
  - fermer la modale avec la bonne m√©thode

Tips : 
- si on veut selectionner plusieurs √©l√©ments, on pense √† `querySelectorAll` ;
- si on a plusieurs √©l√©ments, il faudra donc faire une boucle ;
- pour s√©lectionner la fen√™tre de dialogue, on peut la s√©lectionner par son ID comme d'habitude. Mais on peut √©galement s√©lectionner la fen√™tre active via l'attribut `[open]` et les [s√©lectionnecteur par l'attribut](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) !

</details>

### 2.3. Un peu de rangement üßπ ?

On pourrait rassembler, dans des fonctions sp√©cifiques et bien nomm√©es, :

- les instructions qui posent l'√©couteur pour ouvrir la fen√™tre de dialogue ;  
  > ex : `listenToClickOnAddListModal()`
- les instructions qui posent les √©couteurs pour fermer la fen√™tre de dialogue ;  
  > ex : `listenToClickOnModalClosingElements()`

Puis on s'assure d'appeler ces fonctions lorsque l'int√©gralit√© du DOM est bien charg√© par le navigateur :

```js
document.addEventListener("DOMContentLoaded", () => {
  // maFonction();
  // maFonction2();
});

```

## √âtape 3 - Fetch fetch fetch

### 3.1. Retirer les listes cod√©es en dur

Notre kanban pr√©sente des listes qui ont √©t√© cod√©es en dur dans l'int√©gration.

On les retire pour faire place nette avant d'ins√©rer celles provenants de l'API !

> **ATTENTION** ne pas retirer le conteneur des listes (`lists-container`) dont on aura besoin.

### 3.2. Requ√™ter les listes via l'API

√Ä l'aide d'une requ√™te HTTP (via `fetch`) vers notre API, on r√©cup√®re les donn√©es des listes par la route `GET /lists`.

Rappel de l'utilisation de `fetch` dans une fonction `async`.

```js
const httpResponse = await fetch(URL); // on r√©cup√®re une Response
const data = await httpResponse.json(); // on transforme le corps de la r√©ponse (JSON) en Objet JS
console.log(data);
```

Une fois les donn√©es r√©cup√©r√©es, on les `console.log` et on passe √† la suite : les afficher !

### 3.3. Ins√©rer les listes dans la page

Maintenant que nous avons r√©cup√©r√© les listes, on voudrait les afficher dans la page. On pourrait utiliser des `document.createElement` √† tout va, mais on va vite avoir un sacr√© paquet d'√©l√©ments √† cr√©er‚Ä¶

Mais attendez‚Ä¶ quelle chance ! Nous avons un `<template>` HTML √† notre disposition. On peut donc s'en servir pour ins√©rer nos listes dans la page !

<details><summary>Un peu d'aide ?</summary>

```js
// === PSEUDO CODE ===

// S'assurer d'avoir bien r√©cup√©rer les listes √† l'√©tape pr√©c√©dente : [{ ... }, { ... }, { ... }]

// Pour chaque liste :
// - cloner le template
// - changer le textContent de l'√©l√©ment avec le slot `list-title` (du clone) par le titre de la liste r√©cup√©r√©e
//   - (penser √† faire un querySelector directement sur la variable qui contient le clone !)
// - changer l'id de l'√©l√©ment avec le slot `list-id` (du clone) par l'ID de la liste r√©cup√©r√©e.
//   - (penser √† faire un querySelector directement sur la variable qui contient le clone !)
// - s√©lectionner sur la page l'√©l√©ment conteneur des listes
// - ins√©rer le clone dans le conteneur

// Festoyer !
```

</details>

### 3.4. Un peu de rangement üßπ ?

On pourrait rassembler, dans des fonctions sp√©cifiques et bien nomm√©es, :

- les instructions qui affichent une liste sur la page √† partir des donn√©es d'une liste (objet) fournie en **param√®tre** ;  
  > ex : `addListToListsContainer(listData)`
- les instructions qui vont chercher les listes via l'API dans une fonction qui **retourne** ces listes une fois r√©cup√©r√©es ;  
  > ex : `getLists()`
- et pourquoi pas le tout dans une fonction regroupant les instructions pr√©c√©dentes.  
  > ex : `fetchAndDisplayLists()`

## √âtape 4 - Ajout d'une nouvelle liste

### 4.1. Soumission du formulaire

On reprend notre fen√™tre de dialogue de l'√©tape 2, qui pr√©sente un formulaire HTML `<form>` √† l'utilisateur.

Lorsque l'utilisateur **soumet** (`submit`) ce formulaire , on souhaite :

- emp√™cher le comportement par d√©faut du formulaire ;  
  > `event.preventDefault()` : et oui, on va g√©rer la requ√™te HTTP manuellement !
- r√©cup√©rer les donn√©es du formulaire ;  
  > une [fa√ßon efficace ici](https://www.learnwithjason.dev/blog/get-form-values-as-json/)
- les afficher en `console` pour tester ;
- fermer la fen√™tre de dialogue apr√®s soumission ;
- et √©ventuellement `reset` le formulaire.

Une fois que les donn√©es sont bien affich√©es en `console`, on passe √† la suite.

### 4.2. Sauvegarder la nouvelle liste

Il est temps d'ex√©cuter une requ√™te `POST /lists` vers notre API afin que celle-ci s'occupe de l'ajouter en base de donn√©es.

Rappel de l'utilisation de `fetch` pour une requ√™te POST :

```js
const httpResponse = await fetch(URL, {
  method: "POST", // je cible la route `POST`
  headers: { "Content-Type": "application/json" }, // je pr√©viens que j'envoie du JSON
  body: JSON.stringify(myData), // j'envoie mes donn√©es en JSON
});
const data = await httpResponse.json();
console.log(data); // Les donn√©es JSON renvoy√©es par l'API r√©cup√©r√©es en objet JS
```

On v√©rifie que l'API nous renvoie une r√©ponse correcte et que la liste a bien √©t√© ajout√©e en base de donn√©es.

### 4.3. Ins√©rer la nouvelle liste sur la page

Bonne nouvelle : nous avons d√©j√† cod√© une fonction pour ins√©rer une liste sur la page √† partir des donn√©es d'une liste : `addListToListsContainer(listData)`.
On peut donc la r√©utiliser et ins√©rer la liste fraichement cr√©√©e dans le DOM.

### 4.4. Un peu de rangement üßπ ?

On pourrait rassembler, dans des fonctions sp√©cifiques et bien nomm√©es, :

- les instructions qui √©coutent la soumission du formulaire ;
  > ex : `listenToSubmitOnAddListForm()`
- les instructions qui envoient la requ√™te `POST` et **retourne** les donn√©es renvoy√©es par le serveur ;
  > ex : `createList(listData)`

## Fin

**Bravo !** Vous avez r√©alis√© votre premi√®re ¬´ _Single Page Application_ ¬ª (SPA) qui g√®re les donn√©es de mani√®re dynamique,
sans recharger la page entre chaque changement d'√©tat de la base de donn√©es !
